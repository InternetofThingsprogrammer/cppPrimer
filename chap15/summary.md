#

## 小节

&emsp; &emsp;继承使得我们可以编写一些新的类，这些类技能共享其基类的行为，又能根据需要覆盖或添加行为。动态绑定使得我们可以忽略类型之间差异，其机理是再运行时根据对象的动态类型来选择运行函数的哪个版本。继承和动态绑定的结合使得我们能够编写具有特定类型行为但又独立于类型的程序。  

&emsp; &emsp;在 C++ 语言中，动态绑定只作用于虚函数，并且需要通过指针或者引用调用。  

&emsp; &emsp;在派生类对象中包含有与它的每个基类对应的子对象。因为所有派生类对象都含有基类部分，所以我们可以将派生类的引用或指针转换为一个可访问的基类引用或指针。  

&emsp; &emsp;当执行派生类的构造、拷贝、移动和赋值操作时，首先构造、拷贝、移动和赋值其中的基类部分，然后才轮到派生类部分。析构函数的执行顺序则正好相反，首先撤销派生类，接下来执行基类子对象的析构函数。基类通常都应定义一个虚析构函数，即使基类根本不需要析构函数也最好这么做。将基类的析构函数定义成虚函数的原因是为了确保当我们删除一个基类指针，而该指针实际指向一个派生类对象 时，程序也能正常运行。  

&emsp; &emsp;派生类为它的每个基类提供一个保护级别。public 基类的成员也是派生类接口的一部分；private 基类的成员是不可访问的；protected 基类的成员对于派生类的派生类是可访问的，但是对于派生类的用户不可访问。  

## 术语表

**抽象基类（abstract base class）** 含有一个或多个纯选函数的类，我们我发创建抽象基类的对象。

**可访问的（accessible）** 能被派生类对象访问的极了成员。可访问性由派生类的派生列表中所用的访问说明符和基类中成员的访问级别共同决定。例如，通过公有继承而来的一个公有成员对于派生类的用户来说是可访问的；而私有继承而来的公有成员是不可访问的。  

**基类（base class）** 可供其它类继承的类。基类的成员也将成为派生类的成员。  

**类派生列表（class  derivation list）** 罗列了所有基类，每个基类包含一个可选的访问级别，它定义了派生类继承该基类的方式。如果没有提供访问说明符，则当派生类通过关键字 struct 定义时继承是公有的；而当派生类通过关键字 class 定义时继承是私有的。  

**派生类（derived class）** 从其它类派生而来的类。派生类可以覆盖其基类的虚函数，也可以定义自己的新成员。派生类的作用域嵌套在基类当中；派生类的成员能直接访问基类的成员。  

**派生类向基类的类型转换（derived-to-base conversion）** 派生类对象向基类引用或者派生类指针向基类指针的隐式类型转换。  

**直接基类（direct base class）** 派生类直接继承的基类，直接基类在派生类的派生列表中说明。直接基类本身也可以是一个派生类。  

**动态绑定（dynamic binding）** 直到运行时才决定到底执行函数的哪个版本。在 C++ 语言中，动态绑定的意思是在运行时根据引用或指针所绑定对象的实际类型来选择执行虚函数的某一个版本。  

**动态类型（dynamic type）** 对象在运行时的类型。引用所引对象或指针所指对象的动态类型可能于该引用或指针的静态类型不同。基类的指针或引用可以指向派生类对象。在这样的情况中，静态类型是积累的引用（或指针），而动态类型是派生类的引用（或指针）。  

**间接基类（indirect base class）** 不出现在派生类的派生列表中的基类。直接基类以直接或间接地方式继承地类是派生类的间接基类。  

**继承（inheritance）** 由一个已有的类（基类）定义一个新类（派生类）的编程技术。派生类将继承基类的成员。  

**面向对象编程（object-oriented programming）** 利用数据抽象、继承以及动态绑定等技术编写程序的方法。  

**覆盖（override）** 派生类中定义的虚函数如果于基类中定义的同名虚函数由相同的形参列表，则派生类版本将覆盖基类版本。  

**多态性（polymorphism）** 当用于面向对象编程的范畴时，多态性的含义是程序能通过引用或指针的动态类型获取类型特定行为的功能。  

**私有继承（private inheritance）** 在私有继承中，基类的公有成员和受保护成员是派生类的私有成员。  

**protected 访问说明符（protected access specifier）** protected 关键字之后定义的成员能被派生类的成员和友元访问。但是这些成员只对派生类是可访问的，对类的普通用户则是不可访问的。  

**受保护的继承（protected inheritance）** 在受保护的继承中，基类的公有成员和受保护成员是派生类的受保护成员。  

**公有继承（public inheritance）** 基类的公有接口是派生类的公有接口的组成部分。  

**纯虚函数（pure virtual）** 在类的内部声明虚函数时，在分号之前使用了 =0。一个纯虚函数不需要（但是可以）被定义。含有纯虚函数的类是抽象基类。如果派生类没有对继承而来的纯虚函数定义自己的版本，则该派生类也是抽象的。  

**重构（reactoring）** 重新设计程序以便将一些相关的部分搜集到一个单独的抽象中，然后使用新的抽象替换原来的代码。通常情况下，重构类的方法是将数据成员和函数成员移动到继承体系的高级别节点中，从而避免代码冗余。  

**运行时绑定（run-time binding）** 参见“动态绑定”。

**切掉（sliced down）** 当我们用一个派生类对象初始化一个基类对象或者为基类对象赋值时发生的情况。对象的派生类部分将被“切掉”，只剩下基类部分被赋值给基类对象。  

**静态类型（static type）** 对象被定义的类型或表达式产生的类型。静态类型在编译时是已知的。  

**虚函数（virtual function）** 用于定义类型特定行为的成员函数。通过引用或指针对虚函数的调用直到运行时才被解析，依据是引用或指针所绑定对象的类型。  
